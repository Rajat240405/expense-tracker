-- =============================================================================
-- group_invites schema
-- Append to supabase-schema.sql and run in Supabase SQL Editor
-- =============================================================================
-- PREREQUISITE: This file assumes you have migrated groups to Supabase.
-- If groups are still localStorage-only, the group_id column must be TEXT
-- (storing the client-generated UUID) rather than a FK to a groups table.
-- See the note below each column for both options.
-- =============================================================================


-- ---------------------------------------------------------------------------
-- 1. Create the table
-- ---------------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS group_invites (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- The group this invite belongs to.
  -- Option A (current state — groups in localStorage): plain TEXT
  -- Option B (future — groups in Supabase): UUID REFERENCES groups(id) ON DELETE CASCADE
  group_id    TEXT NOT NULL,

  -- Cryptographically random token, shared in the invite URL.
  -- Generated by the client (crypto.randomUUID()) or server-side.
  token       TEXT NOT NULL UNIQUE,

  -- The authenticated user who created the invite link.
  created_by  UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

  created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- NULL = never expires. Set a value (e.g. NOW() + INTERVAL '7 days')
  -- to enforce expiry at the application level (checked in JoinGroupPage).
  expires_at  TIMESTAMPTZ,

  -- Stamped when the invite is successfully redeemed. NULL = not yet used.
  used_at     TIMESTAMPTZ
);


-- ---------------------------------------------------------------------------
-- 2. Indexes
-- ---------------------------------------------------------------------------

-- Fast lookup by token (the primary use-case on the join page)
CREATE INDEX IF NOT EXISTS idx_group_invites_token
  ON group_invites(token);

-- Fast lookup of all invites for a group (for the dashboard UI)
CREATE INDEX IF NOT EXISTS idx_group_invites_group_id
  ON group_invites(group_id);


-- ---------------------------------------------------------------------------
-- 3. Row Level Security
-- ---------------------------------------------------------------------------

ALTER TABLE group_invites ENABLE ROW LEVEL SECURITY;

-- Policy: Any authenticated user can READ an invite by token.
-- The application validates group membership and expiry after fetching.
-- (We cannot do a server-side group-member check here without a cloud
-- groups table, so we allow any auth'd user to read and enforce in app.)
CREATE POLICY "Authenticated users can read invites by token"
  ON group_invites
  FOR SELECT
  TO authenticated              -- deny anon/service role by default
  USING (auth.uid() IS NOT NULL);

-- Policy: Only authenticated users can CREATE invites.
-- Deeper group-membership check must be enforced in the application layer
-- until the groups table exists in Supabase.
CREATE POLICY "Authenticated users can create invites"
  ON group_invites
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = created_by);

-- Policy: Only the creator can UPDATE (e.g. stamp used_at).
-- We also allow the joiner to stamp used_at via a Supabase RPC call
-- (see invite_group_member function below) which runs as SECURITY DEFINER.
CREATE POLICY "Creator can update their own invites"
  ON group_invites
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = created_by);

-- Policy: Only the creator can DELETE an invite.
CREATE POLICY "Creator can delete their own invites"
  ON group_invites
  FOR DELETE
  TO authenticated
  USING (auth.uid() = created_by);


-- ---------------------------------------------------------------------------
-- 4. Database function: redeem_invite
--
-- This runs as SECURITY DEFINER (elevated privileges) so the joining user
-- can atomically: validate the token, check expiry, stamp used_at — all in
-- one transaction without needing an UPDATE policy for non-creators.
--
-- Called from JoinGroupPage.tsx via:
--   supabase.rpc('redeem_invite', { p_token: token })
-- ---------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION redeem_invite(p_token TEXT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_invite  group_invites%ROWTYPE;
  v_user_id UUID := auth.uid();
BEGIN
  -- Must be authenticated
  IF v_user_id IS NULL THEN
    RETURN json_build_object('error', 'not_authenticated');
  END IF;

  -- Fetch invite
  SELECT * INTO v_invite
  FROM group_invites
  WHERE token = p_token
  FOR UPDATE;           -- lock the row to prevent a concurrent double-redeem

  IF NOT FOUND THEN
    RETURN json_build_object('error', 'invalid_token');
  END IF;

  -- Already used?
  IF v_invite.used_at IS NOT NULL THEN
    RETURN json_build_object('error', 'already_used');
  END IF;

  -- Expired?
  IF v_invite.expires_at IS NOT NULL AND v_invite.expires_at < NOW() THEN
    RETURN json_build_object('error', 'expired');
  END IF;

  -- Stamp used_at
  UPDATE group_invites
  SET used_at = NOW()
  WHERE id = v_invite.id;

  -- Return the group_id so the frontend can add the user to the group
  RETURN json_build_object(
    'ok',       true,
    'group_id', v_invite.group_id
  );
END;
$$;
